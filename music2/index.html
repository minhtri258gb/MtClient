<!DOCTYPE html>
<html>
<head>

	<title>Music</title>
	<meta charset='utf-8' />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link href="/music/favicon.ico" rel="shortcut icon" type="image/png">
	<link href="/lib/fontawesome-6.7.2/css/all.min.css" type="text/css" rel="stylesheet">
	<link href="/lib/sweetalert2-11.22.4/sweetalert2.css" type="text/css" rel="stylesheet">
	<script src="/lib/sweetalert2-11.22.4/sweetalert2.all.min.js"></script>
	<link href="/lib/tabulator-6.3/css/tabulator.min.css" type="text/css" rel="stylesheet">
	<script src="/lib/tabulator-6.3/js/tabulator.min.js" type="text/javascript"></script>
	<link href="/lib/tingle/tingle.min.css" type="text/css" rel="stylesheet">
	<link href="/lib/mt/tingle/mt-style.css" type="text/css" rel="stylesheet">
	<script src="/lib/tingle/tingle.min.js" type="text/javascript"></script>
	<link href="/lib/mt/json-editor/mt-style.css" type="text/css" rel="stylesheet">
	<script src="/lib/json-editor-2.15.2/jsoneditor.min.js"></script>

	<style>
		html, body {
			height: 100%;
			margin: 0;
		}
		.layoutMain {
			width: 100%;
			height: 100%;
			display: flex;
			flex-direction: row;

			.layoutLeft {
				width: 400px;
				height: 100%;
				padding: 0 4px;
				border-right: 1px solid #95B8E7;
				overflow-y: auto;
				overflow-x: hidden;

				.framebox {
					border: 1px solid #95B8E7;
					border-radius: 5px;

					.toolbox-content {
						display: none;
						margin-top: 6px;
						border-top: 1px solid #95B8E7;
					}
				}
			}
			.layoutCenter {
				flex: 1;
			}
		}

		/* Custom Component */
		button.iconButton {
			width: 25px;
			height: 25px;
			color: #444;
			border: 1px solid #bbb;
			border-radius: 5px;
			cursor: pointer;

			&:hover {
				background-color: #eaf2ff;
				border: 1px solid #b7d2ff;
			}

			&.confirmButton {
				color: #0054e9;
			}
			&.dangerButton {
				color: #c5000f;
			}
		}
		.range-vertical {
			writing-mode: vertical-lr;
			direction: rtl;
			width: 22px;
			height: 120px;
			margin: 0;
		}

		/* === Tabulator === */
		.tabulator {
			background-color: white;
			border: none;
		}
		.tabulator .tabulator-header .tabulator-col {
			background: #f2faff;
		}
		.tabulator .tabulator-row:hover {
			background-color: #e6f3ff;
		}
		.tabulator-row {
			background-color: #fff;
			border-bottom: 1px dotted #ccc;
		}
		.tabulator-row.tabulator-row-even {
			background-color: #fff;
		}
		.tabulator-row.highlight-row {
			background-color: #ffe48d;
		}
		.tabulator-row .tabulator-cell {
			border-right: 1px dotted #ccc;
		}

		/* === Sweetalwer2 === */
		.swal2-html-container {
			text-align: left;
		}
	</style>
</head>
<body>

	<!--
		https://tabulator.info
		https://fontawesome.com/v6/search?ic=free&o=r
		https://github.com/json-editor/json-editor
		https://sweetalert2.github.io
	-->

	<div class="layoutMain">
		<div class="layoutLeft">

			<!-- Tiêu đề -->
			<h2 id="titleMusic" style="text-align:center">Music Player</h2>
			<br>

			<!-- Ảnh sóng âm -->
			<canvas id="dynamicWave" class="framebox" style="width:100%;height:100px;"></canvas>
			<br>

			<!-- Thời lượng -->
			<div class="framebox" style="width:100%;height:100px;position:relative;">
				<canvas id="staticWave" style="width:100%;height:100%;z-index:1;"></canvas>
				<span id="staticWaveCur" style="left:0px;width:1px;height:100%;position:absolute;z-index:2;background-color:#95B8E7;"></span>
				<div style="height:15px;top:50%;left:50%;position:absolute;transform:translate(-50%,-50%);z-index:3;">
					<span id="staticWaveTime">0:00</span> / <span id="staticWaveDuration">0:00</span>
				</div>
			</div>
			<br>

			<!-- Player -->
			<div class="framebox" style="height:173px;">

				<!-- Volume bên trái -->
				<div style="width:40px;height:100%;float:left;position:relative;display:flex;flex-direction:column;border-right:ridge;border-width:thin;">

					<!-- Volume Slider -->
					<div style="margin:auto;margin-top:10px;width:fit-content;flex-grow:1;">
						<input id="volumeBar" type="range" class="range-vertical" onchange="mt.event.volumeChange()" />
					</div>

					<!-- Volume Button -->
					<div style="bottom:0;width:100%;height:40px;display:table;">
						<div style="display:table-cell;vertical-align:middle;text-align:center;">
							<button id="volumeBtn" class="iconButton" onclick="mt.event.volumeToggle()" title="Âm lượng"><i class="fa-solid fa-volume-low"></i></button>
						</div>
					</div>

				</div>

				<!-- Controller bên phải -->
				<div style="height:100%;margin-left:50px;padding:5px 5px 5px 5px;">

					<!-- Button -->
					<div style="text-align:center;margin-right:50px;">
						<button class="iconButton" onclick="mt.event.btnBack()" title="Bài trước"><i class="fa-solid fa-backward"></i></button>
						<button id="btnPause" class="iconButton" onclick="mt.event.btnPause()" title="Tạm dừng / phát tiếp"><i class="fa-solid fa-play"></i></button>
						<button class="iconButton" onclick="mt.event.btnNext()" title="Bài tiếp theo"><i class="fa-solid fa-forward"></i></button>
					</div>

					<div style="display:flex;justify-content:space-between;">

						<!-- Visualizations -->
						<div>
							<input id="ckbWave" type="checkbox" onchange="mt.event.ckbWave()" checked>Wave</input>
						</div>

						<!-- Random -->
						<div>
							<input id="ckbNext" type="checkbox" onchange="mt.event.ckbNext()" checked>Auto next</input>
						</div>
					</div>

					<!-- Loop -->
					<div style="text-align:center;margin-top:12px;margin-right:60px;">
						<label>Loop </label>
						<input id="loop" type="number" min="0" max="99" value="0" style="width:32px;" />
						<button class="iconButton" onclick="mt.event.btnLoopIncrease()" title="Tăng lặp lại"><i class="fa-solid fa-arrow-up"></i></button>
					</div>

					<!-- Filter -->
					<div style="margin-top:5px;">
						<span style="display:inline-block;width:32px;">Inc </span><input id="tagInclude" type="text" style="width: calc(100% - 40px);" />
						<br>
						<span style="display:inline-block;width:32px;">Exc </span><input id="tagExclude" type="text" style="width: calc(100% - 40px);" />
					</div>

				</div>
			</div>
			<br>

			<!-- Playlist -->
			<ul id="playlist" class="framebox" style="min-height:18px;margin:0;">
			</ul>
			<br>

			<!-- Toolbox -->
			<div class="framebox" style="padding:8px;">
				<div style="display:flex;gap:4px;">
					<button class="iconButton" onclick="mt.tools.run('check')" title="Kiểm tra file nhạc"><i class="fa-solid fa-list-check"></i></button>
					<button class="iconButton" onclick="mt.tools.run('track')" title="Soundtrack"><i class="fa-solid fa-scissors"></i></button>
					<button class="iconButton" onclick="mt.tools.run('share')" title="Chia sẻ"><i class="fa-solid fa-share-nodes"></i></button>
				</div>
				<div id="toolbox-check" class="toolbox-content">
					<div style="margin:4px 4px 0 0; display:flex;justify-content:center;gap:4px">
						<button onclick="mt.tools.check.addAll()" title="Thêm toàn bộ" class="iconButton"><i class="fa-solid fa-square-plus"></i></button>
					</div>
					<ol id="toolbox-check-list"></ol>
				</div>
				<div id="toolbox-track" class="toolbox-content">
					<div style="margin:4px 4px 0 0; display:flex;justify-content:center;gap:4px">
						<button onclick="mt.tools.track.play()" title="Chạy thử bản track" class="iconButton"><i class="fa-solid fa-play"></i></button>
						<button onclick="mt.tools.track.save()" title="Lưu track" class="iconButton"><i class="fa-solid fa-floppy-disk"></i></button>
					</div>
					<div style="margin-top:8px;display:flex;justify-content:space-around">
						<input id="toolbox-track-begin" type="text">
						<span >-</span>
						<input id="toolbox-track-end" type="text">
					</div>
				</div>
			</div>
			<br>

		</div>
		<div class="layoutCenter">

			<!-- Tabulator -->
			<div id="table"></div>

		</div>
	</div>

	<script type="module">
		import mtAuthen from '/common/authen.js';
		import JsonEditorEX from '/lib/mt/json-editor/mt-script.js';

		var mt = {
			p_authen: mtAuthen,

			// Module
			mgr: {
				h_pathMusic: '', // Link folder on Server
				h_pathDB: '/res/DB/music.json', // Link Data Client
				m_clientPath: '', // Đường dẫn client
				d_musics: [], // Danh sách nhạc
				d_arrayBufferFile: '', // arrayBuffer bài hiện tại để tạo sóng
				d_blogUrl: '', // Blob URL bài hiện tại
				d_randSeed: [], // Danh sách tỷ lệ ngẫu nhiên
				d_history: [], // Danh sách lịch sử phát

				async loadConfig() {

					// Call API - read Enviroment
					let response = await fetch('/common/getConfig?key=PATH_MUSIC', { method: 'GET' });
					if (!response.ok)
						throw { error: true, msg: await response.text() };

					this.h_pathMusic = await response.text();
				},
				processParamURL() {
					let urlParams = new URLSearchParams(window.location.search);
					let idStr = urlParams.get('id');
					let id = Number.parseInt(idStr);
					if (isNaN(id) == false) {
						if (id >= 0 && id < this.d_musics.length) {
							let music = this.d_musics[id-1];
							mt.player.addPlaylist(music);
						}
					}
				},
				async loadFromJson() {
					try {

						// DB Path
						let listMusic = [];
						let urlDB = this.h_pathDB;

						// Call API
						let response = await fetch(urlDB, { method: 'GET' });
						if (!response.ok) {
							if (response.status == 404) { } // skip
							else
								throw { error: true, message: await response.text() };
						}
						else
							listMusic = await response.json();

						// Process data
						for (let i=0, sz=listMusic.length; i<sz; i++) {
							let music = listMusic[i];
							music.id = i+1; // Thêm ID
						}
						this.d_musics = listMusic;

						// Build RandSeed
						this.buildRandomSeed();

						// Set into calendar
						mt.list.load(listMusic);
					}
					catch (ex) {
						console.error('[mt.mgr.loadFromJson] Exception', ex);
						throw ex;
					}
				},
				async saveToJson() {
					try {

						// Authen
						if (mt.p_authen.checkAuthn() == false)
							await mt.p_authen.init();

						// Kiểm tra và lấy client path
						if (this.m_clientPath.length == 0) {
							let response = await fetch('/file/getClientPath', {
								method: 'GET',
								headers: { 'Authorization': 'Bearer ' + mt.p_authen.getToken() },
							});
							if (!response.ok)
								throw { error: true, message: await response.text() };

							this.m_clientPath = await response.text();
						}

						// Bỏ id
						let listData = [];
						for (let music of this.d_musics) {
							let clone = Object.assign({}, music);
							delete clone.id;
							listData.push(clone);
						}

						// Call API - Lưu dữ liệu
						let paramURL = new URLSearchParams();
						paramURL.set('file', this.m_clientPath + this.h_pathDB);
						paramURL.set('force', true);
						let responseSave = await fetch('/file/writeText?' + paramURL.toString(), {
							method: 'POST',
							headers: {
								'Content-Type': 'text/plain',
								'Authorization': 'Bearer ' + mt.p_authen.getToken(),
							},
							body: JSON.stringify(listData),
						});
						if (!responseSave.ok) {
							let errorMessage = await responseSave.text();
							this.toast('error', errorMessage);
							console.error(errorMessage);
							return;
						}
					}
					catch (ex) {
						console.error('[mt.mgr.saveToJson] Exception', ex);
						throw ex;
					}
				},
				async loadFile(filename) {
					try {

						// Call API - Load file
						let paramsURL = new URLSearchParams();
						paramsURL.append('folder', this.h_pathMusic);
						paramsURL.append('file', filename + '.mp3');
						let response = await fetch('/file/static?' + paramsURL.toString());
						if (response.ok == false) {
							if (response.status == 404)
								throw { error: true, message: `Không tìm thấy file nhạc: "${filename}"` };
							else
								throw { error: true, message: await response.text() };
						}

						this.d_arrayBufferFile = await response.arrayBuffer();

						// Giải phóng dữ liệu cũ và mã hóa dữ liệu mới
						if (this.d_blogUrl.length > 0)
							URL.revokeObjectURL(this.d_blogUrl);
						this.d_blogUrl = URL.createObjectURL(new Blob([this.d_arrayBufferFile]));
					}
					catch (ex) {
						throw { error: true, message: ex.message, detail: ex };
					}
				},
				buildRandomSeed() {
					this.d_randSeed = [];
					for (let i=0, sz=this.d_musics.length; i<sz; i++) {
						let music = this.d_musics[i];
						// Bỏ bài miss
						if (music.miss)
							continue;
						// Thêm seed bằng rate tương ứng
						for (let j=0; j<music.rate; j++)
							this.d_randSeed.push(i);
					}
				},
			},
			list: {
				p_table: null, // Tabulator

				init() {

					this.p_table = new Tabulator('#table', {
						layout: 'fitData',
						height: '100%',
						renderVertical: 'basic', // Tắt virtual DOM
						// autoRowHeight: true, // Từ động wraptext
						// filterMode: 'remote', // Filter
						// headerFilterLiveFilterDelay: 600,
						// sortMode: 'remote', // Sort
						// initialSort: [{column: 'time', dir: 'desc'}],
						data: [],
						initialSort: [{ column: 'name', dir: 'asc' }],
						columns: [
							{ title:'STT', formatter:'rownum', width:40, hozAlign:'center', vertAlign:'middle', headerSort:false },
							{ title:'Name', field:'name', vertAlign:'middle', headerSort:false, editable:false, editable:false },
							{ title:'Rate', field:'rate', width:62, hozAlign:'center', vertAlign:'middle', editable:false, formatter: (cell) => {
								let value = cell.getValue(); // Lấy giá trị của ô (1-5)
								return (value >= 1 && value <= 5) ? `<img src="/res/icons/rating${value}.png" />` : 'N/A';
							}},
							{ title:'Duration', field:'duration', width:64, hozAlign:'center', vertAlign:'middle', headerSort:false, editable:false,
								formatter: (cell) => mt.utils.cv_formatTime(cell.getValue()),
							},
							{ title:'Tags', field:'tags', width:100, vertAlign:'middle', headerSort:false, editable:false },
							{ title:'Track', field:'trackbegin', width:45, hozAlign:'center', vertAlign:'middle', headerSort:false, editable:false, formatter: (cell) => {
								let value = cell.getValue(); // Lấy giá trị trackbegin
								return value == null ? '': '<i class="fa-regular fa-circle-check" style="color:#2dd55b"></i>';
							}},
						],
						// editorEmptyValue: null,
						rowContextMenu: [
							{ label: '<i class="fa-solid fa-square-plus"></i> Add Playlist', action: (event, row) => mt.event.menuAddPlaylist(row) },
							{ label: '<i class="fa-solid fa-play"></i> Play', action: (event, row) => mt.event.menuPlay(row) },
							{ label: '<i class="fa-solid fa-circle-play"></i> Play Track', action: (event, row) => mt.event.menuPlayTrack(row) },
							{ separator: true, },
							{ label: '<i class="fa-solid fa-pen-to-square"></i> Edit', action: (event, row) => mt.event.menuEdit(row) },
							{ label: '<i class="fa-regular fa-trash-can"></i> Delete', action: (event, row) => mt.event.menuDelete(row) },
							{ separator: true, },
							{ label: '<i class="fa-solid fa-print"></i> Print', action: (event, row) => mt.event.menuPrint(row) },
						],
						// headerSortElement: function(column, dir) {
						// 	switch (dir) {
						// 		case 'asc': return '<img src="/res/icons/sort_up_9x16.png" />';
						// 		case 'desc': return '<img src="/res/icons/sort_down_9x16.png" />';
						// 	}
						// 	return '<img src="/res/icons/sort_9x16.png" />';
						// },
						rowFormatter: (row) => {
							let data = row.getData();
							if (data.miss)
								row.getElement().style.backgroundColor = '#ffebee';
						}
					});

					// Register Event
					this.p_table.on('cellDblClick', (event, cell) => mt.event.doubleClickList(cell));
				},
				load(lstRow) {
					this.p_table.setData(lstRow);
				},
				highlightRow(id) {

					// Xóa highlight cũ
					document.querySelectorAll('.highlight-row').forEach(el => {
						el.classList.remove('highlight-row');
					});

					// Highlight dòng hiện tại
					let row = this.p_table.getRow(id);
					row.getElement().classList.add('highlight-row');
				},
				scrollToCurrent(id) {
					this.p_table.scrollToRow(id, 'center', true);
				},
			},
			form: {
				c_modal: null, // tingle
				c_form: null, // jsoneditor

				// Method
				init() {

					// Init Modal - tingle
					this.c_modal = new tingle.modal({
						footer: false,
						stickyFooter: false,
						closeMethods: ['button', 'escape'], // 'overlay'
						closeLabel: "Đóng",
						onOpen: function() {
							// console.log('modal opened');
						},
						onClose: function() {
							// console.log('modal closed');
						},
						beforeClose: function() {
							// Return true to close the modal, false to prevent closing
							return true;
						},
					});
					this.c_modal.setContent('<div id="music-form" class="json-editor"></div>');

					// Init Form - jsoneditor
					JsonEditorEX.RateRegister();
					JsonEditorEX.TagBoxRegister();
					const elementForm = document.getElementById('music-form');
					elementForm.style.width = '500px';
					elementForm.parentElement.parentElement.style.width = 'unset'; // Bỏ width gốc
					this.c_form = new JSONEditor(elementForm, {
						use_name_attributes: false,
						theme: 'barebones',
						iconlib: 'fontawesome5',
						disable_edit_json: true,
						disable_properties: true,
						disable_collapse: true,
						schema: {
							title: 'Music',
							type: 'object',
							required: [],
							properties: {
								'id': { type: 'string', format: 'hidden', options: { titleHidden: true } },
								'name': { title: 'Name', type: 'string', format: 'text' },
								'rate': { title: 'Rate', type: 'integer', format: 'rate', default: 3 },
								'duration': { title: 'Duration', type: 'number', minimum: 0 },
								'tags': { title: 'Tags', type: 'array', format: 'tagbox', items: { type: 'string' } },
								'decibel': { title: 'Decibel', type: 'number', minimum: 0, maximum: 500 },
								'trackbegin': { title: 'Track begin', type: 'number', minimum: 0 },
								'trackend': { title: 'Track end', type: 'number', minimum: 0 },
								'miss': { title: 'Miss', type: 'boolean', format: 'checkbox' },
								'save': { title: 'Save', type: 'string', format: 'button', options: { button: { icon: 'save', action: () => this.save() }}},
								'cancel': { title: 'Cancel', type: 'string', format: 'button', options: { button: { icon: 'close', action: () => this.c_modal.close() }}},
							},
						},
					});
				},
				async open(music) {

					// Set form data
					this.c_form.setValue(music);

					// Open Modal
					this.c_modal.open();

					// Log
					mt.h_debug && console.log('[mt.form.open]', { music });
				},
				async save() {
					try {
						
						// Get data
						let data = this.c_form.getValue(); // mt.form.c_form.getValue()

						// Process data
						if (data.trackbegin == '')
							data.trackbegin = null;
						if (data.trackend == '')
							data.trackend = null;

						if (data.id === 0) { // Add

							// Add Index
							data.id = mt.mgr.d_musics.length + 2; // Chưa push + lệch 1, bắt đầu từ 1 => +2

							// Save to RAM
							mt.mgr.d_musics.push(data);

							// Build lại seed để auto play random ko lệch
							mt.mgr.buildRandomSeed();

							// Thêm vào tabulator
							await mt.list.p_table.addRow(data);

							// Sắp xếp lại tabulator
							mt.list.p_table.setSort('name', 'asc');

							// Log
							// console.log('[mt.form.onSave]', { data });
						}
						else { // Update

							// Log
							// console.log('[mt.form.onSave]', {
							// 	old: Object.assign({}, mt.mgr.d_musics[arrIndex]),
							// 	new: Object.assign({}, data),
							// });

							// Save to RAM
							mt.mgr.d_musics[data.id - 1] = data;

							// Change Tabulator
							mt.list.p_table.updateRow(data.id, data);
						}

						// Save data
						await mt.mgr.saveToJson();

						// Close modal
						this.c_modal.close();

						// Notify
						mt.utils.toast('success', "Lưu dữ liệu ảnh thành công.");
					}
					catch (ex) {
						// Swal.showValidationMessage('Dữ liệu nhập chưa hợp lệ!');
						mt.utils.toast('error', ex.message);
						console.error('[mt.form.saveForm] Exception:', ex);
					}
				},
				async delete(music) {

					// Confirm Popup
					let isConfirm = await mt.utils.confirmDanger(`Xác nhận xóa bài ${music.name}?`, 'Xóa');
					if (!isConfirm)
						return;

					// Save to RAM
					mt.mgr.d_musics.splice(music.id-1, 1);

					// Build lại seed để auto play random ko lệch
					mt.mgr.buildRandomSeed();

					// Xóa khỏi tabulator
					mt.list.p_table.deleteRow(music.id);

					// Save data
					await mt.mgr.saveToJson();

					// Notify
					mt.utils.toast('success', `Đã xóa dữ liệu bài ${music.name}`);

					// Log
					console.log('[mt.form.delete]', { music });
				},
				cv_inForm(data) {
					return {
						id: data?.id || 0,
						name: data?.name || '',
						rate: data?.rate || 3,
						duration: data?.duration || 0,
						tags: data?.tags || ['NEW'],
						decibel: data?.decibel || 100,
						trackbegin: data?.trackbegin || 0,
						trackend: data?.trackend || 0,
						miss: data?.miss || false,
					};
				},
				cv_outForm(data) {
					return {
						id: Number.parseInt(data.id), // Convert Int
						name: data.name,
						rate: data.rate,
						duration: data.duration == 0 ? null : data.duration, // Bằng 0 thì null
						tags: data.tags,
						decibel: data.decibel,
						trackbegin: data.trackbegin == 0 ? null : data.trackbegin, // Bằng 0 thì null
						trackend: data.trackend == 0 ? null : data.trackend, // Bằng 0 thì null
						miss: data.miss == 'true', // Convert Boolean
					};
				},
			},
			player: {
				h_defaultVolume: 0.3, // Âm lượng mặc định của loa
				c_audio: null, // Element Audio
				c_title: null, // Element Title music
				c_volumeBar: null, // Volume Slide
				c_volumeBtn: null, // Volume Button
				c_pause: null, // Element Button Pause
				c_ckbNext: null, // Checkbox auto next
				c_loop: null, // Element Input Loop
				c_playlist: null, // Element playlist
				p_audioContext: null, // AudioContext
				m_currentMusic: null, // Data bài phát hiện tại
				m_track: { id:null, begin:0, end:0 }, // Bài track hiện tại
				m_interact: false, // Cờ đặt lại trạng thái AudioContext sau tương tác
				m_volumeBase: 1, // Volume chuẩn (chưa thay đổi theo từng bài)
				m_volumeMute: false, // Cờ tắt âm thanh
				m_autoNext: true, // Cờ tự random bài tiếp theo
				d_playList: [], // Danh sách nhạc

				init() {

					// Variable
					this.m_volumeBase = this.h_defaultVolume;

					// Audio Context
					window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext;
					this.p_audioContext = new AudioContext();

					// Audio Component
					let audio = new Audio();
					audio.volume = this.m_volumeBase;
					audio.addEventListener('ended', (event) => this.onEnd(event));
					// audio.addEventListener('loadeddata', () => this.onLoadedData());
					// audio.addEventListener('canplaythrough', () => this.onReady()); // canplaythrough sự kiện này call khi seek, dễ lỗi
					audio.addEventListener('timeupdate', () => this.onTimeUpdate());
					this.c_audio = audio;

					// Controller
					this.c_title = document.getElementById('titleMusic');
					this.c_volumeBar = document.getElementById('volumeBar');
					this.c_volumeBtn = document.getElementById('volumeBtn');
					this.c_pause = document.getElementById('btnPause');
					this.c_ckbNext = document.getElementById('ckbNext');
					this.c_loop = document.getElementById('loop');
					this.c_playlist = document.getElementById('playlist');

					// UI
					this.c_volumeBar.value = this.m_volumeBase * 100;
				},
				async onTimeUpdate() { // Quá trình chạy nhạc

					// Data
					let currentTime = this.c_audio.currentTime;

					// Cập nhật hiển thị wave static
					mt.wave.staticUpdate(currentTime);

					// CASE 1: Kiểm tra nếu như có track và đến thời điểm thì pause lại
					if (this.m_track.id == this.m_currentMusic.id && currentTime > this.m_track.end) {

						// Ngừng phát
						this.c_audio.pause();

						// Đổi icon
						this.setIconPause(false);

						// Kết thúc track
						this.m_track.id = null;
						return;
					}
				},
				onEnd(event) { // Kết thúc chạy nhạc

					// CASE 1: Nếu có loop thì chạy lại
					let loop = this.c_loop.value;
					if (loop > 0) {
						this.c_loop.value--;
						this.c_audio.currentTime = 0;
						this.c_audio.play();
						return
					}

					// Cập nhật Icon khi kết thúc
					this.setIconPause(false);

					// CASE 2: Lấy từ danh sách chờ nếu có
					// CASE 3: Lấy ngẫu nhiên từ danh sách nhạc
					// 2 case này có trong playNext
					this.playNext();
				},
				async addPlaylist(music) {

					// CASE 1: Nếu bài đang chạy thì chỉ tăng loop
					if (this.m_currentMusic != null && music.id == this.m_currentMusic.id) {
						mt.player.c_loop.value++;
						return;
					}

					// CASE 2: Nếu bài có sẵn thì tăng loop trong playlist
					let item = this.d_playList.find(o => o.id == music.id);
					if (item != null) {

						// Cập nhật loop
						item.loop++;

						// Tìm Element danh sách chờ có sẵn nhạc chưa
						let elementItem = document.getElementById('playlist-item-'+music.id);
						elementItem.textContent = music.name + ` (${item.loop})`;
					}
					// CASE 3: Thêm bài vào playlist
					else {

						// Change data
						this.d_playList.push({
							id: music.id,
							name: music.name,
							loop: 1,
						});

						// Render list
						const li = document.createElement('li');
						li.id = 'playlist-item-' + music.id;
						li.textContent = music.name;
						this.c_playlist.appendChild(li);
					}
				},
				async pause(flag) {

					// Nếu ko có sẵn nhạc thì cho qua
					if (this.m_currentMusic == null) {
						this.playNext();
						return;
					}

					// Nếu ko có toggle thì chuyển trạng thái hiện tại
					if (flag == null)
						flag = (this.c_audio.paused == false);

					if (flag) {

						// Đổi trạng thái
						this.c_audio.pause();

						// Đổi icon button pause
						this.setIconPause(false);
					}
					else {

						// Đổi trạng thái
						await this.c_audio.play();

						// Đổi icon button pause
						this.setIconPause(true);
					}
				},
				seek(time) {
					this.c_audio.currentTime = time;
				},
				async playNext() {

					// Dừng nhạc hiện tại
					this.c_audio.pause();

					// Lưu lại lịch sử
					if (this.m_currentMusic != null)
						mt.mgr.d_history.push(this.m_currentMusic.id);

					// CASE 1: Lấy bài từ playlist nếu có
					// Tìm danh sách playlist có bài không?
					if (this.d_playList.length > 0) {

						// Lấy nhạc đầu danh sách
						let musicNext = this.d_playList[0];
						let id = musicNext.id;

						// Xóa bản đó khỏi data và giao diện
						this.d_playList.splice(0, 1);
						let elMusicList = document.getElementById('playlist-item-' + id);
						elMusicList.remove();

						// Phát nhạc
						let music = mt.mgr.d_musics[id-1];
						this.playMusic(music);
					}
					// CASE 2: Lấy bài ngẫu nhiên trong danh sách nhạc nếu AutoNext được bật
					else if (this.m_autoNext) {
						let len = mt.mgr.d_randSeed.length;
						let seed = Math.floor(Math.random() * len);
						let arrIndex = mt.mgr.d_randSeed[seed];
						let music = mt.mgr.d_musics[arrIndex];
						this.playMusic(music);
					}
				},
				playBack() {

					// nếu có lịch sử thì back về
					if ( mt.mgr.d_history.length == 0) {
						mt.utils.toast('warning', 'Chưa có lịch sử chơi nhạc!');
						return;
					}

					// Dừng nhạc hiện tại
					this.c_audio.pause();

					// Lấy bài gần nhất
					let id =  mt.mgr.d_history.pop();
					let music = mt.mgr.d_musics[id - 1];

					// Chạy nhạc
					this.playMusic(music);
				},
				async playForce(music) {

					// CASE 1: Nếu bài đang chạy thì chỉ tăng loop
					if (this.m_currentMusic != null && this.m_currentMusic.id == music.id) {
						mt.player.c_loop.value++;
						return;
					}

					// CASE 2: Chạy trực tiếp bài này

					// Dừng nhạc hiện tại
					this.c_audio.pause();

					// Set loop value
					this.c_loop.value = 0;

					// Play music
					this.playMusic(music);
				},
				async playTrack(music) {

					// Kiểm tra data có track ko
					if (music.trackbegin == null || music.trackend == null) {
						mt.utils.toast('warning', 'Chưa có track!'); // Thông báo
						return;
					}

					// Đặt track
					this.m_track = {
						id: music.id,
						begin: music.trackbegin,
						end: music.trackend,
					};

					// CASE 1: Bài hiện tại là bài này
					if (this.m_currentMusic != null && this.m_currentMusic.id == music.id) {
						this.c_audio.pause();
						this.c_audio.currentTime = this.m_currentMusic.trackbegin;
						this.c_audio.play();

						// Đổi icon button pause
						this.setIconPause(true);
						return;
					}

					// CASE 2: Chạy track trực tiếp bài này
					this.playMusic(music);
				},
				volumeChange() {

					// Điều chỉnh âm lượng
					let volume = this.c_volumeBar.value;
					if (this.m_currentMusic != null && this.m_currentMusic.decibel) // Điều chỉnh theo nhạc
						volume *= (this.m_currentMusic.decibel / 100);
					this.c_audio.volume = volume / 100;

					// Cập nhật icon button
					let icon = 'off';
					if (volume > 60)
						icon = 'high';
					else if (volume > 20)
						icon = 'low';
					this.c_volumeBtn.innerHTML = `<i class="fa-solid fa-volume-${icon}"></i>`;
				},
				volumeToggle() {
					let isMute = this.m_volumeMute;
					if (this.m_volumeMute) {

						// Điều chỉnh âm lượng
						this.volumeChange();
					}
					else {

						// Điều chỉnh âm lượng
						this.c_audio.volume = 0;

						// Cập nhật icon
						this.c_volumeBtn.innerHTML = `<i class="fa-solid fa-volume-xmark"></i>`;
					}
					this.m_volumeMute = !isMute;
				},
				async playMusic(music) {
					try {

						// Chỉnh lại audioContext sau tương tác
						if (!this.m_interact && this.p_audioContext.state === 'suspended')
							this.p_audioContext.resume();

						// Load blob music
						await mt.mgr.loadFile(music.name);

						// Bind blob to Audio
						this.c_audio.pause();
						this.c_audio.src = mt.mgr.d_blogUrl;
						this.c_audio.load();

						// Change state
						this.m_currentMusic = music;

						// Generate Wave
						mt.wave.staticGenerate(mt.mgr.d_arrayBufferFile); // Dùng arrayBuffer sau khi load file

						// Change title
						this.c_title.innerHTML = music.name;
						document.title = music.name;

						// Highlight color row
						mt.list.highlightRow(music.id);

						// Nếu ko phải doubleClickList và menuPlay thì focus row bài hát
						if (['doubleClickList','menuPlay','menuPlayTrack'].includes(mt.event.m_action) == false)
							mt.list.scrollToCurrent(music.id);

						// Đợi cho đến khi load xong
						await new Promise((resolve, reject) => {
							let wait = setInterval(() => {
								if (this.c_audio.readyState >= 3) {
									clearInterval(wait);
									resolve();
								}
							}, 50);
						});

						// Cập nhật duration nếu bài chưa có
						if (music.duration != this.c_audio.duration)
							music.duration = this.c_audio.duration;

						// Nếu đang có track thì đặt điểm khởi đầu
						if (this.m_track.id == music.id)
							this.c_audio.currentTime = this.m_track.begin;
						else // Đã đổi bài, xóa track
							this.m_track.id = null;

						// Change icon button Pause
						this.setIconPause(true)

						// Hiển thị duration
						mt.wave.c_staticWaveDuration.innerHTML = mt.utils.cv_formatTime(music.duration);

						// Bắt đầu phát
						this.c_audio.play();

						// Extra - Tool Track - Nếu đang mở tool track thì điền begin và end vào input
						if (mt.tools.m_open == 'track')
							mt.tools.track.setTime(music);
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.error('[mt.player.playMusic] Exception:', ex);
					}
				},
				setIconPause(toggle) {
					this.c_pause.innerHTML = `<i class="fa-solid fa-${toggle ? 'pause' : 'play'}"></i>`;
				},
				changeAutoNext() {

					// Nghịch đảo lại
					this.m_autoNext = this.c_ckbNext.checked;
				},
			},
			wave: {
				c_staticWave: null, // SoundWave tĩnh
				c_staticWaveCur: null, // Thanh thời điểm phát
				c_staticWaveTime: null, // Thời điểm hiện tại
				c_staticWaveDuration: null, // Thời lượng phát
				c_dynamicWave: null, // SoundWave động
				c_ckbWave: null, // Checkbox Wave
				p_canvasContext: null, // CanvasContext
				m_currentTime: 0, // Thời gian hiện tại
				m_waveType: true, // true: wave, false: shake

				init() {

					// Bind Component
					this.c_staticWave = document.getElementById('staticWave');
					this.c_staticWaveCur = document.getElementById('staticWaveCur');
					this.c_staticWaveTime = document.getElementById('staticWaveTime');
					this.c_staticWaveDuration = document.getElementById('staticWaveDuration');
					this.c_dynamicWave = document.getElementById('dynamicWave');
					this.c_ckbWave = document.getElementById('ckbWave');

					// Register Event
					this.c_staticWave.addEventListener('click', (event) => mt.event.clickStaticWave(event), false);
					this.c_dynamicWave.addEventListener('click', () => mt.event.clickDynamicWave(), false);

					// Context
					this.p_canvasContext = this.c_staticWave.getContext('2d');

					this.dynamicInit();
				},
				onClickDynamic() {
				},
				staticClear() {
					this.p_canvasContext.fillStyle = 'rgba(0,0,0,1)';
					this.p_canvasContext.globalCompositeOperation = 'destination-out';
					this.p_canvasContext.clearRect(0, 0, this.c_staticWave.width, this.c_staticWave.height);
				},
				staticGenerate(res) {
					mt.player.p_audioContext.decodeAudioData(res, (buffer) => {

						// buffer: AudioBuffer

						let w = this.c_staticWave.clientWidth;
						let h = this.c_staticWave.clientHeight;
						this.staticGenSizeW = w;

						this.c_staticWave.width = w;
						this.c_staticWave.height = h;

						this.p_canvasContext.fillStyle = '#f0f0f0'; // Màu xám nhạt
						this.p_canvasContext.globalCompositeOperation = 'source-over';

						let data = buffer.getChannelData(0);
						let step = Math.ceil(data.length / w);
						let amp = h / 2;
						for (let i=0; i < w; i++) {
							let min = 1.0;
							let max = -1.0;
							for (let j=0; j<step; j++) {
								let datum = data[(i*step)+j];
								if (datum < min) min = datum;
								if (datum > max) max = datum;
							}
							this.p_canvasContext.fillRect(i,(1+min)*amp,1,Math.max(1,(max-min)*amp));
						}

						this.p_canvasContext.globalCompositeOperation = 'source-atop';
						this.m_currentTime = 0;
					});
				},
				staticUpdate(currentTime) {
					let w = this.c_staticWave.clientWidth;
					let h = this.c_staticWave.clientHeight;
					let pos = currentTime / mt.player.m_currentMusic.duration * w;

					// Hiển thị thời gian
					this.c_staticWaveTime.innerHTML = mt.utils.cv_formatTime(currentTime);

					// Cập nhật vị trí thanh current
					this.c_staticWaveCur.style.left = pos+'px';

					// Vẽ current cho static
					pos = pos * this.staticGenSizeW / w; // Fix lỗi scale khi resize window
					if (currentTime > this.m_currentTime) {
						this.p_canvasContext.fillStyle = '#ffe48d'; // màu cam
						this.p_canvasContext.fillRect(0, 0, pos, h);
					}
					else {
						this.p_canvasContext.fillStyle = '#f0f0f0'; // Màu xám nhạt
						this.p_canvasContext.fillRect(pos, 0, w, h);
					}

					this.m_currentTime = currentTime;
				},
				dynamicInit() {

					// Global
					let elAudio = mt.player.c_audio;
					let audioContext = mt.player.p_audioContext;

					let analyser = audioContext.createAnalyser();
					analyser.fftSize = 128;

					let source = audioContext.createMediaElementSource(elAudio); // Gây lỗi ko phát nhạc được

					source.connect(audioContext.destination);
					source.connect(analyser);
					
					// source.connect(analyser);
					// analyser.connect(audioContext.destination);

					let bufferLength = analyser.frequencyBinCount;
					let dataArray = new Uint8Array(bufferLength);

					let canvas = this.c_dynamicWave;
					canvas.width = canvas.clientWidth;
					canvas.height = canvas.clientHeight;

					let ctx = canvas.getContext('2d');
					let WIDTH = canvas.width;
					let HEIGHT = canvas.height;

					let heightWave;

					// For type 1
					let sizeloop = Math.ceil(bufferLength * 2 / 3);
					let barWidth = WIDTH / bufferLength * 1.5 - 2;
					let gradient = ctx.createLinearGradient(0, 0, 0, HEIGHT);
					gradient.addColorStop(1.0, '#fff8af');
					gradient.addColorStop(0.5, '#ffe48d');
					gradient.addColorStop(0.0, '#bba040');
					// gradient.addColorStop(1.0, '#fff7bf');
					// gradient.addColorStop(0.5, '#ffe48d');
					// gradient.addColorStop(0.0, '#ccb15a');
					let capYPositionArray = new Array(sizeloop); // Lưu lịch sử vị trí Cap

					// For type 2
					let HEIGHTHALF = HEIGHT / 2;
					ctx.lineWidth = 2; // line width
					ctx.strokeStyle = '#000'; // line color
					const sliceWidth = WIDTH / bufferLength;
					const scaleFactor = 5 / 2;

					function renderFrame() {
						requestAnimationFrame(renderFrame);
						ctx.clearRect(0, 0, WIDTH, HEIGHT); // reset canvas

						if (mt.wave.m_waveType) {
							analyser.getByteFrequencyData(dataArray); // 0 - 255
							for (let i = 0, x = 0; i < sizeloop; i++) {
								heightWave = dataArray[i] / 256 * HEIGHT;
								
								// Render Bar
								ctx.fillStyle = gradient;
								ctx.fillRect(x, HEIGHT - heightWave, barWidth, heightWave);

								// Render Cap
								if (heightWave < capYPositionArray[i])
									heightWave = --capYPositionArray[i];
								else
									capYPositionArray[i] = heightWave;
								ctx.fillStyle = '#000';
								ctx.fillRect(x, HEIGHT - heightWave - 2, barWidth, 2);

								x += barWidth + 2;
							}
						}
						else {
							analyser.getByteTimeDomainData(dataArray);
							ctx.beginPath();
							ctx.moveTo(0, HEIGHTHALF);
							for (var i=0, x = sliceWidth/2; i < bufferLength; i++) {
								// 0 > 255 | 0 > 2 | -1 > 1 | scale 5/2 | to height
								heightWave = (dataArray[i] / 128.0 - 1) * scaleFactor * HEIGHTHALF + HEIGHTHALF;
								ctx.lineTo(x, heightWave);
								x += sliceWidth;
							}
							ctx.lineTo(WIDTH, HEIGHTHALF);
							ctx.stroke();
						}
					}
					renderFrame();
				},
				changeWaveType() {

					// Nghịch đảo lại
					this.m_waveType = this.c_ckbWave.checked;
				},
			},
			tools: {
				m_open: '',

				check: {
					c_content: null,
					c_list: null,
					d_listNew: [],
					d_listMiss: [],

					async open() {

						// Authen
						if (mt.p_authen.checkAuthn() == false)
							await mt.p_authen.init();

						// Call API - Lấy danh sách file trong thư mục nhạc
						let paramsURL = new URLSearchParams();
						paramsURL.append('folder', mt.mgr.h_pathMusic);
						let response = await fetch('/file/list?' + paramsURL.toString(), {
							method: 'GET',
							headers: { 'Authorization': 'Bearer ' + mt.p_authen.getToken() },
						});
						if (!response.ok)
							throw { error: true, message: await response.text(), detail: response };

						let listFile = await response.json();

						// Tạo mapping
						let mapFile = {};
						for (let file of listFile) {
							if (file.isFolder)
								continue;
							let name = file.name.substring(0, file.name.length-4); // Bỏ .mp3
							mapFile[name] = true; //file;
						}

						// Tìm bài bị miss, bài đã có thì xóa khỏi map, còn lại sẽ là bài mới
						this.d_listMiss = [];
						for (let music of mt.mgr.d_musics) {
							let name = music.name;
							if (mapFile[name] != null) { // Nếu có
								music.miss = false;
								delete mapFile[name];
							}
							else { // Nếu ko
								music.miss = true;
								this.d_listMiss.push(name);
							}
						}
						this.d_listNew = [];
						for (let name in mapFile) {
							// let file = mapFile[name];
							this.d_listNew.push(name);
						}

						// Clean list
						this.c_list.innerHTML = '';

						// Show New
						for (let name of this.d_listNew) {
							const li = document.createElement('li');
							// const button = document.createElement('button');
							// button.title = 'Thêm bài này';
							// button.classList.add('iconButton');
							// button.classList.add('confirmButton');
							// button.innerHTML = '<i class="fa-solid fa-plus"></i>';
							// button.addEventListener('click', () => this.add(name, li));
							// li.appendChild(button);
							// li.append(' ' + name);
							li.append(name);
							this.c_list.appendChild(li);
						}

						// Show miss
						// for (let name of this.d_listMiss) {
						// 	const button = document.createElement('button');
						// 	button.title = 'Xóa bài này';
						// 	button.classList.add('iconButton');
						// 	button.classList.add('dangerButton');
						// 	button.innerHTML = '<i class="fa-solid fa-xmark"></i>';
						// 	button.addEventListener('click', () => this.remove(name));

						// 	const li = document.createElement('li');
						// 	li.appendChild(button);
						// 	li.append(' ' + name);

						// 	this.c_list.appendChild(li);
						// }

						// Log
						// console.log('[mt.tools.check.open]', { listFile });
					},
					async addAll() {

						for (let name of this.d_listNew) {

							let musicNew = {
								name: name,
								duration: null,
								decibel: 100,
								rate: 3,
								tags: ['NEW'],
								trackbegin: null,
								trackend: null,
								miss: false,
							};

							// Thêm vào list
							mt.mgr.d_musics.push(musicNew);

							// Thêm vào tabulator
							await mt.list.p_table.addRow(musicNew);
						}

						// Sắp xếp lại danh sách và tabulator
						mt.mgr.d_musics.sort((a, b) => a.name.localeCompare(b.name)); // .toLowerCase()
						mt.list.p_table.setSort('name', 'asc');

						// Build lại seed để auto play random ko lệch
						mt.mgr.buildRandomSeed();

						// Clean list check
						this.c_list.innerHTML = '';
						this.d_listNew = [];

						// Lưu lại file music.json
						mt.mgr.saveToJson();

						// Close tool check
						this.c_content.style.display = 'none';

						// Notify
						mt.utils.toast('success', `Đã thêm toàn bộ bài mới`);

						// Log
						console.log('[mt.tools.check.addAll]', {  });
					},
				},
				track: {
					c_content: null,
					c_begin: null,
					c_end: null,

					init() {
						this.c_content = document.getElementById('toolbox-track');
						this.c_begin = document.getElementById('toolbox-track-begin');
						this.c_end = document.getElementById('toolbox-track-end');
					},
					open() {
						if (mt.player.m_currentMusic == null)
							return;

						let music = mt.player.m_currentMusic;
						if (music.trackbegin != null && music.trackbegin > 0)
							this.c_begin.value = music.trackbegin;
						if (music.trackend != null && music.trackend > 0)
							this.c_end.value = music.trackend;
					},
					play() {
						try {
							if (mt.player.m_currentMusic == null)
								return;

							let music = mt.player.m_currentMusic;

							// Kiểm tra
							let timeBeginStr = this.c_begin.value;
							let timeEndStr = this.c_end.value;
							if (timeBeginStr.length == 0 || timeEndStr.length == 0)
								throw { error: true, msg: 'Chưa nhập timeBegin, timeEnd' };

							// Chuyển format MM:ss thành second
							if (timeBeginStr.indexOf(':') > -1) {
								timeBeginStr = mt.utils.cv_reFormatTime(timeBeginStr);
								this.c_begin.value = timeBeginStr;
							}
							if (timeEndStr.indexOf(':') > -1) {
								timeEndStr = mt.utils.cv_reFormatTime(timeEndStr);
								this.c_end.value = timeEndStr;
							}

							// Kiểm tra
							let timeBegin = Number.parseFloat(timeBeginStr);
							let timeEnd = Number.parseFloat(timeEndStr);
							if (isNaN(timeBegin) || isNaN(timeEnd))
								throw { error: true, msg: 'timeBegin, timeEnd không hợp lệ' };

							// Set state
							mt.player.m_track = {
								id: music.id,
								begin: timeBegin,
								end: timeEnd,
							};

							// Seek
							mt.player.seek(timeBegin);
							mt.player.pause(false);

							// Log
							// console.log('[mt.tools.track.play]', { timeBegin, timeEnd });
						}
						catch (ex) {
							mt.utils.toast('error', ex.message);
						}
					},
					save() {
						if (mt.player.m_currentMusic == null)
							return;

					},
					setTime(music) {
						this.c_begin.value = music.trackbegin;
						this.c_end.value = music.trackend;
					},
				},
				share: {
					async run() {

						// Lấy Port hiện tại
						let URL = location.origin + location.pathname;
						if (URL.indexOf('localhost') > -1) {

							// Call API - Get IP
							let response = await fetch('/common/getIPLocal', { method: 'GET' });
							if (!response.ok)
								throw { error: true, message: await response.text() };

							let IP = await response.text();

							URL = URL.replace('localhost', IP);
						}

						// Thêm params query
						let paramURL = new URLSearchParams();
						paramURL.append('id', mt.player.m_currentMusic.id);
						URL += '?' + paramURL.toString();

						// Tự động copy
						if (window.isSecureContext) {
							await navigator.clipboard.writeText(URL);
							mt.utils.toast('success', 'Đã copy link nhạc.');
						}
						else {
							console.log(URL);
							mt.utils.toast('warning', 'Chưa cấp quyền truy cập bộ nhớ đệm! Lấy link trong console.');
						}
					},
				},

				init() {

					// Bind Component
					this.check.c_content = document.getElementById('toolbox-check');
					this.check.c_list = document.getElementById('toolbox-check-list');
					this.track.init();
				},
				async run(tool) {
					try {

						// Hide all
						this.check.c_content.style.display = 'none';
						this.track.c_content.style.display = 'none';

						// Run tool
						switch (tool) {
							case 'check':
								this.check.c_content.style.display = 'block';
								await this.check.open();
								break;
							case 'track':
								this.track.c_content.style.display = 'block';
								this.track.open();
								break;
							case 'share':
								// Nếu chưa chọn bài thì bỏ qua
								if (mt.player.m_currentMusic == null) {
									mt.utils.toast('warning', 'Chưa chọn nhạc!');
									return;
								}
								await this.share.run();
								break;
						}
						this.m_open = tool;
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.tools.run]', ex);
					}
				},
			},
			event: {
				m_action: '',

				clickDynamicWave() { // Click vào sóng âm động
					try {
						this.m_action = 'clickDynamicWave';

						// Nếu chưa chọn bài thì bỏ qua
						if (mt.player.m_currentMusic == null)
							return;

						// Move to row
						mt.list.scrollToCurrent(mt.player.m_currentMusic.id);
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.clickDynamicWave]', ex);
					}
				},
				clickStaticWave() { // Click vào sóng âm tĩnh
					try {
						this.m_action = 'clickStaticWave';

						// Nếu chưa chọn bài thì bỏ qua
						if (mt.player.m_currentMusic == null)
							return;

						// Hủy track nếu có
						if (mt.player.m_track.id != null)
							mt.player.m_track.id = null;

						// Seek
						let duration = mt.player.m_currentMusic.duration;
						let curTime = event.offsetX / event.target.offsetWidth * duration;
						mt.player.seek(curTime);
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.clickStaticWave]', ex);
					}
				},
				volumeChange() { // Chỉnh âm lượng
					try {
						this.m_action = 'volumeChange';
						mt.player.volumeChange();
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.volumeChange]', ex);
					}
				},
				volumeToggle() { // Bật / tắt âm thanh
					try {
						this.m_action = 'volumeToggle';
						mt.player.volumeToggle();
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.volumeToggle]', ex);
					}
				},
				btnBack() { // Lùi về bài trước
					try {
						this.m_action = 'btnBack';
						mt.player.playBack();
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.btnBack]', ex);
					}
				},
				btnPause() { // Tạm dừng / phát tiếp
					try {
						this.m_action = 'btnPause';
						mt.player.pause();
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.btnPause]', ex);
					}
				},
				btnNext() { // Bài tiếp theo
					try {
						this.m_action = 'btnNext';
						mt.player.playNext();
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.btnNext]', ex);
					}
				},
				btnLoopIncrease() { // Tăng loop
					try {
						this.m_action = 'btnNext';
						mt.player.c_loop.stepUp(1);
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.btnLoopIncrease]', ex);
					}
				},
				ckbWave() { // Đổi loại sóng âm nhạc
					try {
						this.m_action = 'ckbWave';
						mt.wave.changeWaveType();
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.ckbWave]', ex);
					}
				},
				ckbNext() { // Tự động random bài tiếp
					try {
						this.m_action = 'ckbNext';
						mt.player.changeAutoNext();
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.ckbNext]', ex);
					}
				},
				doubleClickList(cell) { // Nhấn đúp chọn bài trên danh sách
					try {
						this.m_action = 'doubleClickList';
						mt.player.playForce(cell.getRow().getData());
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.doubleClickList]', ex);
					}
				},
				menuAddPlaylist(row) { // Thêm vào hàng chờ
					try {
						this.m_action = 'menuAddPlaylist';
						mt.player.addPlaylist(row.getData());
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.menuAddPlaylist]', ex);
					}
				},
				menuPlay(row) { // Phát bài đang chọn
					try {
						this.m_action = 'menuPlay';
						mt.player.playForce(row.getData());
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.menuPlay]', ex);
					}
				},
				menuPlayTrack(row) { // Phát soundtrack bài đang chọn
					try {
						this.m_action = 'menuPlayTrack';
						mt.player.playTrack(row.getData());
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.menuPlayTrack]', ex);
					}
				},
				menuEdit(row) { // Mở form chỉnh sửa
					try {
						this.m_action = 'menuEdit';
						mt.form.open(row.getData());
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.menuEdit]', ex);
					}
				},
				menuDelete(row) { // Xóa bài này
					try {
						this.m_action = 'menuDelete';
						mt.form.delete(row.getData());
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.menuDelete]', ex);
					}
				},
				menuPrint(row) { // Console log bài này
					try {
						this.m_action = 'menuPrint';
						console.log(row.getData());
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.menuPrint]', ex);
					}
				},
				pressSpace() { // Nhấn cách
					try {
						this.m_action = 'pressSpace';
						mt.player.pause();
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.pressSpace]', ex);
					}
				},
				pressEnter() { // Nhấn enter
					try {
						this.m_action = 'pressEnter';
						mt.player.playNext();
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.pressEnter]', ex);
					}
				},
				pressMediaPlayPause() { // Nhấn phím media dừng / phát
					try {
						this.m_action = 'pressMediaPlayPause';
						mt.player.pause();
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.pressMediaPlayPause]', ex);
					}
				},
				mediaPlay() { // Controller Browser
					try {
						this.m_action = 'mediaPlay';
						mt.player.pause(false);
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.mediaPlay]', ex);
					}
				},
				mediaPause() { // Controller Browser
					try {
						this.m_action = 'mediaPause';
						mt.player.pause(true);
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.mediaPause]', ex);
					}
				},
				mediaBack() { // Controller Browser
					try {
						this.m_action = 'mediaBack';
						mt.player.playBack();
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.mediaBack]', ex);
					}
				},
				mediaNext() { // Controller Browser
					try {
						this.m_action = 'mediaNext';
						mt.player.playNext()
					}
					catch (ex) {
						mt.utils.toast('error', ex.message);
						console.log('[mt.event.mediaNext]', ex);
					}
				},
			},
			utils: {
				p_toast: null, // Sweetalert2 - Toast

				init() {

					// Bind window event
					window.addEventListener('keydown', (event) => this.onKeyPress(event));

					// Register browser Media
					this.registerMedia();

					// Init Sweetlert2
					this.p_toast = Swal.mixin({
						toast: true,
						position: 'bottom-end',
						showConfirmButton: false,
						timer: 3000,
						timerProgressBar: true,
						didOpen: (toast) => {
							toast.onmouseenter = Swal.stopTimer;
							toast.onmouseleave = Swal.resumeTimer;
						},
					});
				},
				registerMedia() {
					navigator.mediaSession.setActionHandler('play', () => mt.event.mediaPlay());
					navigator.mediaSession.setActionHandler('pause', () => mt.event.mediaPause());
					navigator.mediaSession.setActionHandler('previoustrack', () => mt.event.mediaBack());
					navigator.mediaSession.setActionHandler('nexttrack', () => mt.event.mediaNext());
				},
				toast(type, message) {

					// Show Toast
					this.p_toast.fire({ icon: type, title: message });
				},
				async confirmDanger(message, action) {
					let result = await Swal.fire({
						title: message,
						icon: 'warning',
						showCancelButton: true,
						confirmButtonColor: '#d33',
						confirmButtonText: action,
						cancelButtonText: 'Hủy'
					});
					return result.isConfirmed;
				},
				onKeyPress(event) {

					let isAction = true;
					switch (event.code) {
						case 'Space': mt.event.pressSpace(); break;
						case 'Enter': mt.event.pressEnter(); break;
						default: isAction = false;
					}

					if (!isAction) {
						isAction = true;
						switch (event.key) {
							case 'MediaPlayPause': mt.event.pressMediaPlayPause(); break;
							default: isAction = false;
						}
					}

					if (isAction)
						event.preventDefault();
					return !isAction;
				},
				cv_formatTime(value) {
					if (value == null || value.length == 0)
						return '';
					let valueR = Math.floor(value);
					let minute = Math.floor(valueR / 60);
					let second = valueR % 60;
					if (second < 10)
						second = '0' + second;
					return minute + ':' + second;
				},
				cv_reFormatTime(value) {
					let pos = value.indexOf(':');
					let minute = +value.substring(0, pos);
					let second = +value.substring(pos+1);
					return minute * 60  + second;
				},
			},

			// Method
			async init() {

				// Bind Global
				window.mt = this;

				// Read Config
				await this.mgr.loadConfig();

				// Init
				this.list.init();

				this.form.init();

				this.player.init();

				// Wave khởi tạo sau player để có Element Audio
				this.wave.init();

				this.tools.init();
				this.utils.init();

				// First Load
				await this.mgr.loadFromJson();

				// Process URL Params
				this.mgr.processParamURL()
			},
		};
		document.addEventListener('DOMContentLoaded', () => mt.init());
	</script>
</body>
</html>